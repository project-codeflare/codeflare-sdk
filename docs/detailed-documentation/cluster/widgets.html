<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>codeflare_sdk.cluster.widgets API documentation</title>
<meta name="description" content="The widgets sub-module contains the ui widgets created using the ipywidgets package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>codeflare_sdk.cluster.widgets</code></h1>
</header>
<section id="section-intro">
<p>The widgets sub-module contains the ui widgets created using the ipywidgets package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2024 IBM, Red Hat
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
The widgets sub-module contains the ui widgets created using the ipywidgets package.
&#34;&#34;&#34;
import contextlib
import io
import os
import warnings
import time
import codeflare_sdk
from kubernetes import client
from kubernetes.client.rest import ApiException
import ipywidgets as widgets
from IPython.display import display, HTML, Javascript
import pandas as pd
from .config import ClusterConfiguration
from .model import RayClusterStatus
from ..utils.kube_api_helpers import _kube_api_error_handling
from .auth import config_check, get_api_client


def cluster_up_down_buttons(cluster: &#34;codeflare_sdk.cluster.Cluster&#34;) -&gt; widgets.Button:
    &#34;&#34;&#34;
    The cluster_up_down_buttons function returns two button widgets for a create and delete button.
    The function uses the appwrapper bool to distinguish between resource type for the tool tip.
    &#34;&#34;&#34;
    resource = &#34;Ray Cluster&#34;
    if cluster.config.appwrapper:
        resource = &#34;AppWrapper&#34;

    up_button = widgets.Button(
        description=&#34;Cluster Up&#34;,
        tooltip=f&#34;Create the {resource}&#34;,
        icon=&#34;play&#34;,
    )

    delete_button = widgets.Button(
        description=&#34;Cluster Down&#34;,
        tooltip=f&#34;Delete the {resource}&#34;,
        icon=&#34;trash&#34;,
    )

    wait_ready_check = wait_ready_check_box()
    output = widgets.Output()

    # Display the buttons in an HBox wrapped in a VBox which includes the wait_ready Checkbox
    button_display = widgets.HBox([up_button, delete_button])
    display(widgets.VBox([button_display, wait_ready_check]), output)

    def on_up_button_clicked(b):  # Handle the up button click event
        with output:
            output.clear_output()
            cluster.up()

            # If the wait_ready Checkbox is clicked(value == True) trigger the wait_ready function
            if wait_ready_check.value:
                cluster.wait_ready()

    def on_down_button_clicked(b):  # Handle the down button click event
        with output:
            output.clear_output()
            cluster.down()

    up_button.on_click(on_up_button_clicked)
    delete_button.on_click(on_down_button_clicked)


def wait_ready_check_box():
    &#34;&#34;&#34;
    The wait_ready_check_box function will return a checkbox widget used for waiting for the resource to be in the state READY.
    &#34;&#34;&#34;
    wait_ready_check_box = widgets.Checkbox(
        False,
        description=&#34;Wait for Cluster?&#34;,
    )
    return wait_ready_check_box


def is_notebook() -&gt; bool:
    &#34;&#34;&#34;
    The is_notebook function checks if Jupyter Notebook environment variables exist in the given environment and return True/False based on that.
    &#34;&#34;&#34;
    if (
        &#34;PYDEVD_IPYTHON_COMPATIBLE_DEBUGGING&#34; in os.environ
        or &#34;JPY_SESSION_NAME&#34; in os.environ
    ):  # If running Jupyter NBs in VsCode or RHOAI/ODH display UI buttons
        return True
    else:
        return False


def view_clusters(namespace: str = None):
    &#34;&#34;&#34;
    view_clusters function will display existing clusters with their specs, and handle user interactions.
    &#34;&#34;&#34;
    if not is_notebook():
        warnings.warn(
            &#34;view_clusters can only be used in a Jupyter Notebook environment.&#34;
        )
        return  # Exit function if not in Jupyter Notebook

    from .cluster import get_current_namespace

    if not namespace:
        namespace = get_current_namespace()

    user_output = widgets.Output()
    raycluster_data_output = widgets.Output()
    url_output = widgets.Output()

    ray_clusters_df = _fetch_cluster_data(namespace)
    if ray_clusters_df.empty:
        print(f&#34;No clusters found in the {namespace} namespace.&#34;)
        return

    classification_widget = widgets.ToggleButtons(
        options=ray_clusters_df[&#34;Name&#34;].tolist(),
        value=ray_clusters_df[&#34;Name&#34;].tolist()[0],
        description=&#34;Select an existing cluster:&#34;,
    )
    # Setting the initial value to trigger the event handler to display the cluster details.
    initial_value = classification_widget.value
    _on_cluster_click(
        {&#34;new&#34;: initial_value}, raycluster_data_output, namespace, classification_widget
    )
    classification_widget.observe(
        lambda selection_change: _on_cluster_click(
            selection_change, raycluster_data_output, namespace, classification_widget
        ),
        names=&#34;value&#34;,
    )

    # UI table buttons
    delete_button = widgets.Button(
        description=&#34;Delete Cluster&#34;,
        icon=&#34;trash&#34;,
        tooltip=&#34;Delete the selected cluster&#34;,
    )
    delete_button.on_click(
        lambda b: _on_delete_button_click(
            b,
            classification_widget,
            ray_clusters_df,
            raycluster_data_output,
            user_output,
            delete_button,
            list_jobs_button,
            ray_dashboard_button,
        )
    )

    list_jobs_button = widgets.Button(
        description=&#34;View Jobs&#34;, icon=&#34;suitcase&#34;, tooltip=&#34;Open the Ray Job Dashboard&#34;
    )
    list_jobs_button.on_click(
        lambda b: _on_list_jobs_button_click(
            b, classification_widget, ray_clusters_df, user_output, url_output
        )
    )

    ray_dashboard_button = widgets.Button(
        description=&#34;Open Ray Dashboard&#34;,
        icon=&#34;dashboard&#34;,
        tooltip=&#34;Open the Ray Dashboard in a new tab&#34;,
        layout=widgets.Layout(width=&#34;auto&#34;),
    )
    ray_dashboard_button.on_click(
        lambda b: _on_ray_dashboard_button_click(
            b, classification_widget, ray_clusters_df, user_output, url_output
        )
    )

    display(widgets.VBox([classification_widget, raycluster_data_output]))
    display(
        widgets.HBox([delete_button, list_jobs_button, ray_dashboard_button]),
        url_output,
        user_output,
    )


def _on_cluster_click(
    selection_change,
    raycluster_data_output: widgets.Output,
    namespace: str,
    classification_widget: widgets.ToggleButtons,
):
    &#34;&#34;&#34;
    _on_cluster_click handles the event when a cluster is selected from the toggle buttons, updating the output with cluster details.
    &#34;&#34;&#34;
    new_value = selection_change[&#34;new&#34;]
    raycluster_data_output.clear_output()
    ray_clusters_df = _fetch_cluster_data(namespace)
    classification_widget.options = ray_clusters_df[&#34;Name&#34;].tolist()
    with raycluster_data_output:
        display(
            HTML(
                ray_clusters_df[ray_clusters_df[&#34;Name&#34;] == new_value][
                    [
                        &#34;Name&#34;,
                        &#34;Namespace&#34;,
                        &#34;Num Workers&#34;,
                        &#34;Head GPUs&#34;,
                        &#34;Head CPU Req~Lim&#34;,
                        &#34;Head Memory Req~Lim&#34;,
                        &#34;Worker GPUs&#34;,
                        &#34;Worker CPU Req~Lim&#34;,
                        &#34;Worker Memory Req~Lim&#34;,
                        &#34;status&#34;,
                    ]
                ].to_html(escape=False, index=False, border=2)
            )
        )


def _on_delete_button_click(
    b,
    classification_widget: widgets.ToggleButtons,
    ray_clusters_df: pd.DataFrame,
    raycluster_data_output: widgets.Output,
    user_output: widgets.Output,
    delete_button: widgets.Button,
    list_jobs_button: widgets.Button,
    ray_dashboard_button: widgets.Button,
):
    &#34;&#34;&#34;
    _on_delete_button_click handles the event when the Delete Button is clicked, deleting the selected cluster.
    &#34;&#34;&#34;
    cluster_name = classification_widget.value
    namespace = ray_clusters_df[ray_clusters_df[&#34;Name&#34;] == classification_widget.value][
        &#34;Namespace&#34;
    ].values[0]

    _delete_cluster(cluster_name, namespace)

    with user_output:
        user_output.clear_output()
        print(
            f&#34;Cluster {cluster_name} in the {namespace} namespace was deleted successfully.&#34;
        )

    # Refresh the dataframe
    new_df = _fetch_cluster_data(namespace)
    if new_df.empty:
        classification_widget.close()
        delete_button.close()
        list_jobs_button.close()
        ray_dashboard_button.close()
        with raycluster_data_output:
            raycluster_data_output.clear_output()
            print(f&#34;No clusters found in the {namespace} namespace.&#34;)
    else:
        classification_widget.options = new_df[&#34;Name&#34;].tolist()


def _on_ray_dashboard_button_click(
    b,
    classification_widget: widgets.ToggleButtons,
    ray_clusters_df: pd.DataFrame,
    user_output: widgets.Output,
    url_output: widgets.Output,
):
    &#34;&#34;&#34;
    _on_ray_dashboard_button_click handles the event when the Open Ray Dashboard button is clicked, opening the Ray Dashboard in a new tab
    &#34;&#34;&#34;
    from codeflare_sdk.cluster import Cluster

    cluster_name = classification_widget.value
    namespace = ray_clusters_df[ray_clusters_df[&#34;Name&#34;] == classification_widget.value][
        &#34;Namespace&#34;
    ].values[0]

    # Suppress from Cluster Object initialisation widgets and outputs
    with widgets.Output(), contextlib.redirect_stdout(
        io.StringIO()
    ), contextlib.redirect_stderr(io.StringIO()):
        cluster = Cluster(ClusterConfiguration(cluster_name, namespace))
    dashboard_url = cluster.cluster_dashboard_uri()

    with user_output:
        user_output.clear_output()
        print(f&#34;Opening Ray Dashboard for {cluster_name} cluster:\n{dashboard_url}&#34;)
    with url_output:
        display(Javascript(f&#39;window.open(&#34;{dashboard_url}&#34;, &#34;_blank&#34;);&#39;))


def _on_list_jobs_button_click(
    b,
    classification_widget: widgets.ToggleButtons,
    ray_clusters_df: pd.DataFrame,
    user_output: widgets.Output,
    url_output: widgets.Output,
):
    &#34;&#34;&#34;
    _on_list_jobs_button_click handles the event when the View Jobs button is clicked, opening the Ray Jobs Dashboard in a new tab
    &#34;&#34;&#34;
    from codeflare_sdk.cluster import Cluster

    cluster_name = classification_widget.value
    namespace = ray_clusters_df[ray_clusters_df[&#34;Name&#34;] == classification_widget.value][
        &#34;Namespace&#34;
    ].values[0]

    # Suppress from Cluster Object initialisation widgets and outputs
    with widgets.Output(), contextlib.redirect_stdout(
        io.StringIO()
    ), contextlib.redirect_stderr(io.StringIO()):
        cluster = Cluster(ClusterConfiguration(cluster_name, namespace))
    dashboard_url = cluster.cluster_dashboard_uri()

    with user_output:
        user_output.clear_output()
        print(
            f&#34;Opening Ray Jobs Dashboard for {cluster_name} cluster:\n{dashboard_url}/#/jobs&#34;
        )
    with url_output:
        display(Javascript(f&#39;window.open(&#34;{dashboard_url}/#/jobs&#34;, &#34;_blank&#34;);&#39;))


def _delete_cluster(
    cluster_name: str,
    namespace: str,
    timeout: int = 5,
    interval: int = 1,
):
    &#34;&#34;&#34;
    _delete_cluster function deletes the cluster with the given name and namespace.
    It optionally waits for the cluster to be deleted.
    &#34;&#34;&#34;
    from .cluster import _check_aw_exists

    try:
        config_check()
        api_instance = client.CustomObjectsApi(get_api_client())

        if _check_aw_exists(cluster_name, namespace):
            api_instance.delete_namespaced_custom_object(
                group=&#34;workload.codeflare.dev&#34;,
                version=&#34;v1beta2&#34;,
                namespace=namespace,
                plural=&#34;appwrappers&#34;,
                name=cluster_name,
            )
            group = &#34;workload.codeflare.dev&#34;
            version = &#34;v1beta2&#34;
            plural = &#34;appwrappers&#34;
        else:
            api_instance.delete_namespaced_custom_object(
                group=&#34;ray.io&#34;,
                version=&#34;v1&#34;,
                namespace=namespace,
                plural=&#34;rayclusters&#34;,
                name=cluster_name,
            )
            group = &#34;ray.io&#34;
            version = &#34;v1&#34;
            plural = &#34;rayclusters&#34;

        # Wait for the resource to be deleted
        while timeout &gt; 0:
            try:
                api_instance.get_namespaced_custom_object(
                    group=group,
                    version=version,
                    namespace=namespace,
                    plural=plural,
                    name=cluster_name,
                )
                # Retry if resource still exists
                time.sleep(interval)
                timeout -= interval
                if timeout &lt;= 0:
                    raise TimeoutError(
                        f&#34;Timeout waiting for {cluster_name} to be deleted.&#34;
                    )
            except ApiException as e:
                # Resource is deleted
                if e.status == 404:
                    break
    except Exception as e:  # pragma: no cover
        return _kube_api_error_handling(e)


def _fetch_cluster_data(namespace):
    &#34;&#34;&#34;
    _fetch_cluster_data function fetches all clusters and their spec in a given namespace and returns a DataFrame.
    &#34;&#34;&#34;
    from .cluster import list_all_clusters

    rayclusters = list_all_clusters(namespace, False)
    if not rayclusters:
        return pd.DataFrame()
    names = [item.name for item in rayclusters]
    namespaces = [item.namespace for item in rayclusters]
    num_workers = [item.num_workers for item in rayclusters]
    head_extended_resources = [
        f&#34;{list(item.head_extended_resources.keys())[0]}: {list(item.head_extended_resources.values())[0]}&#34;
        if item.head_extended_resources
        else &#34;0&#34;
        for item in rayclusters
    ]
    worker_extended_resources = [
        f&#34;{list(item.worker_extended_resources.keys())[0]}: {list(item.worker_extended_resources.values())[0]}&#34;
        if item.worker_extended_resources
        else &#34;0&#34;
        for item in rayclusters
    ]
    head_cpu_requests = [
        item.head_cpu_requests if item.head_cpu_requests else 0 for item in rayclusters
    ]
    head_cpu_limits = [
        item.head_cpu_limits if item.head_cpu_limits else 0 for item in rayclusters
    ]
    head_cpu_rl = [
        f&#34;{requests}~{limits}&#34;
        for requests, limits in zip(head_cpu_requests, head_cpu_limits)
    ]
    head_mem_requests = [
        item.head_mem_requests if item.head_mem_requests else 0 for item in rayclusters
    ]
    head_mem_limits = [
        item.head_mem_limits if item.head_mem_limits else 0 for item in rayclusters
    ]
    head_mem_rl = [
        f&#34;{requests}~{limits}&#34;
        for requests, limits in zip(head_mem_requests, head_mem_limits)
    ]
    worker_cpu_requests = [
        item.worker_cpu_requests if item.worker_cpu_requests else 0
        for item in rayclusters
    ]
    worker_cpu_limits = [
        item.worker_cpu_limits if item.worker_cpu_limits else 0 for item in rayclusters
    ]
    worker_cpu_rl = [
        f&#34;{requests}~{limits}&#34;
        for requests, limits in zip(worker_cpu_requests, worker_cpu_limits)
    ]
    worker_mem_requests = [
        item.worker_mem_requests if item.worker_mem_requests else 0
        for item in rayclusters
    ]
    worker_mem_limits = [
        item.worker_mem_limits if item.worker_mem_limits else 0 for item in rayclusters
    ]
    worker_mem_rl = [
        f&#34;{requests}~{limits}&#34;
        for requests, limits in zip(worker_mem_requests, worker_mem_limits)
    ]
    status = [item.status.name for item in rayclusters]

    status = [_format_status(item.status) for item in rayclusters]

    data = {
        &#34;Name&#34;: names,
        &#34;Namespace&#34;: namespaces,
        &#34;Num Workers&#34;: num_workers,
        &#34;Head GPUs&#34;: head_extended_resources,
        &#34;Worker GPUs&#34;: worker_extended_resources,
        &#34;Head CPU Req~Lim&#34;: head_cpu_rl,
        &#34;Head Memory Req~Lim&#34;: head_mem_rl,
        &#34;Worker CPU Req~Lim&#34;: worker_cpu_rl,
        &#34;Worker Memory Req~Lim&#34;: worker_mem_rl,
        &#34;status&#34;: status,
    }
    return pd.DataFrame(data)


def _format_status(status):
    &#34;&#34;&#34;
    _format_status function formats the status enum.
    &#34;&#34;&#34;
    status_map = {
        RayClusterStatus.READY: &#39;&lt;span style=&#34;color: green;&#34;&gt;Ready ✓&lt;/span&gt;&#39;,
        RayClusterStatus.SUSPENDED: &#39;&lt;span style=&#34;color: #007BFF;&#34;&gt;Suspended ❄️&lt;/span&gt;&#39;,
        RayClusterStatus.FAILED: &#39;&lt;span style=&#34;color: red;&#34;&gt;Failed ✗&lt;/span&gt;&#39;,
        RayClusterStatus.UNHEALTHY: &#39;&lt;span style=&#34;color: purple;&#34;&gt;Unhealthy&lt;/span&gt;&#39;,
        RayClusterStatus.UNKNOWN: &#39;&lt;span style=&#34;color: purple;&#34;&gt;Unknown&lt;/span&gt;&#39;,
    }
    return status_map.get(status, status)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="codeflare_sdk.cluster.widgets.cluster_up_down_buttons"><code class="name flex">
<span>def <span class="ident">cluster_up_down_buttons</span></span>(<span>cluster: codeflare_sdk.cluster.Cluster) ‑> ipywidgets.widgets.widget_button.Button</span>
</code></dt>
<dd>
<div class="desc"><p>The cluster_up_down_buttons function returns two button widgets for a create and delete button.
The function uses the appwrapper bool to distinguish between resource type for the tool tip.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_up_down_buttons(cluster: &#34;codeflare_sdk.cluster.Cluster&#34;) -&gt; widgets.Button:
    &#34;&#34;&#34;
    The cluster_up_down_buttons function returns two button widgets for a create and delete button.
    The function uses the appwrapper bool to distinguish between resource type for the tool tip.
    &#34;&#34;&#34;
    resource = &#34;Ray Cluster&#34;
    if cluster.config.appwrapper:
        resource = &#34;AppWrapper&#34;

    up_button = widgets.Button(
        description=&#34;Cluster Up&#34;,
        tooltip=f&#34;Create the {resource}&#34;,
        icon=&#34;play&#34;,
    )

    delete_button = widgets.Button(
        description=&#34;Cluster Down&#34;,
        tooltip=f&#34;Delete the {resource}&#34;,
        icon=&#34;trash&#34;,
    )

    wait_ready_check = wait_ready_check_box()
    output = widgets.Output()

    # Display the buttons in an HBox wrapped in a VBox which includes the wait_ready Checkbox
    button_display = widgets.HBox([up_button, delete_button])
    display(widgets.VBox([button_display, wait_ready_check]), output)

    def on_up_button_clicked(b):  # Handle the up button click event
        with output:
            output.clear_output()
            cluster.up()

            # If the wait_ready Checkbox is clicked(value == True) trigger the wait_ready function
            if wait_ready_check.value:
                cluster.wait_ready()

    def on_down_button_clicked(b):  # Handle the down button click event
        with output:
            output.clear_output()
            cluster.down()

    up_button.on_click(on_up_button_clicked)
    delete_button.on_click(on_down_button_clicked)</code></pre>
</details>
</dd>
<dt id="codeflare_sdk.cluster.widgets.is_notebook"><code class="name flex">
<span>def <span class="ident">is_notebook</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The is_notebook function checks if Jupyter Notebook environment variables exist in the given environment and return True/False based on that.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_notebook() -&gt; bool:
    &#34;&#34;&#34;
    The is_notebook function checks if Jupyter Notebook environment variables exist in the given environment and return True/False based on that.
    &#34;&#34;&#34;
    if (
        &#34;PYDEVD_IPYTHON_COMPATIBLE_DEBUGGING&#34; in os.environ
        or &#34;JPY_SESSION_NAME&#34; in os.environ
    ):  # If running Jupyter NBs in VsCode or RHOAI/ODH display UI buttons
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="codeflare_sdk.cluster.widgets.view_clusters"><code class="name flex">
<span>def <span class="ident">view_clusters</span></span>(<span>namespace: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>view_clusters function will display existing clusters with their specs, and handle user interactions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_clusters(namespace: str = None):
    &#34;&#34;&#34;
    view_clusters function will display existing clusters with their specs, and handle user interactions.
    &#34;&#34;&#34;
    if not is_notebook():
        warnings.warn(
            &#34;view_clusters can only be used in a Jupyter Notebook environment.&#34;
        )
        return  # Exit function if not in Jupyter Notebook

    from .cluster import get_current_namespace

    if not namespace:
        namespace = get_current_namespace()

    user_output = widgets.Output()
    raycluster_data_output = widgets.Output()
    url_output = widgets.Output()

    ray_clusters_df = _fetch_cluster_data(namespace)
    if ray_clusters_df.empty:
        print(f&#34;No clusters found in the {namespace} namespace.&#34;)
        return

    classification_widget = widgets.ToggleButtons(
        options=ray_clusters_df[&#34;Name&#34;].tolist(),
        value=ray_clusters_df[&#34;Name&#34;].tolist()[0],
        description=&#34;Select an existing cluster:&#34;,
    )
    # Setting the initial value to trigger the event handler to display the cluster details.
    initial_value = classification_widget.value
    _on_cluster_click(
        {&#34;new&#34;: initial_value}, raycluster_data_output, namespace, classification_widget
    )
    classification_widget.observe(
        lambda selection_change: _on_cluster_click(
            selection_change, raycluster_data_output, namespace, classification_widget
        ),
        names=&#34;value&#34;,
    )

    # UI table buttons
    delete_button = widgets.Button(
        description=&#34;Delete Cluster&#34;,
        icon=&#34;trash&#34;,
        tooltip=&#34;Delete the selected cluster&#34;,
    )
    delete_button.on_click(
        lambda b: _on_delete_button_click(
            b,
            classification_widget,
            ray_clusters_df,
            raycluster_data_output,
            user_output,
            delete_button,
            list_jobs_button,
            ray_dashboard_button,
        )
    )

    list_jobs_button = widgets.Button(
        description=&#34;View Jobs&#34;, icon=&#34;suitcase&#34;, tooltip=&#34;Open the Ray Job Dashboard&#34;
    )
    list_jobs_button.on_click(
        lambda b: _on_list_jobs_button_click(
            b, classification_widget, ray_clusters_df, user_output, url_output
        )
    )

    ray_dashboard_button = widgets.Button(
        description=&#34;Open Ray Dashboard&#34;,
        icon=&#34;dashboard&#34;,
        tooltip=&#34;Open the Ray Dashboard in a new tab&#34;,
        layout=widgets.Layout(width=&#34;auto&#34;),
    )
    ray_dashboard_button.on_click(
        lambda b: _on_ray_dashboard_button_click(
            b, classification_widget, ray_clusters_df, user_output, url_output
        )
    )

    display(widgets.VBox([classification_widget, raycluster_data_output]))
    display(
        widgets.HBox([delete_button, list_jobs_button, ray_dashboard_button]),
        url_output,
        user_output,
    )</code></pre>
</details>
</dd>
<dt id="codeflare_sdk.cluster.widgets.wait_ready_check_box"><code class="name flex">
<span>def <span class="ident">wait_ready_check_box</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The wait_ready_check_box function will return a checkbox widget used for waiting for the resource to be in the state READY.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_ready_check_box():
    &#34;&#34;&#34;
    The wait_ready_check_box function will return a checkbox widget used for waiting for the resource to be in the state READY.
    &#34;&#34;&#34;
    wait_ready_check_box = widgets.Checkbox(
        False,
        description=&#34;Wait for Cluster?&#34;,
    )
    return wait_ready_check_box</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="codeflare_sdk.cluster" href="index.html">codeflare_sdk.cluster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="codeflare_sdk.cluster.widgets.cluster_up_down_buttons" href="#codeflare_sdk.cluster.widgets.cluster_up_down_buttons">cluster_up_down_buttons</a></code></li>
<li><code><a title="codeflare_sdk.cluster.widgets.is_notebook" href="#codeflare_sdk.cluster.widgets.is_notebook">is_notebook</a></code></li>
<li><code><a title="codeflare_sdk.cluster.widgets.view_clusters" href="#codeflare_sdk.cluster.widgets.view_clusters">view_clusters</a></code></li>
<li><code><a title="codeflare_sdk.cluster.widgets.wait_ready_check_box" href="#codeflare_sdk.cluster.widgets.wait_ready_check_box">wait_ready_check_box</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
